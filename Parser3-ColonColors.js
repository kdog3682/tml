export {
    Parser,
}
/* prettier-ignore */ import {fooga, notify, storager, joiner, removeVeryStartingComments, ireplace, removeCommentsInPlace, editf, getLineTokens, IndexedStore, abstractError, bool, xassert, getSetLines, inMiddle, replaceLast, ensureExtension, multipleReplacer, getGradeLevel, constructEdit, getYear, Modulus, wrapClassMethods, proseReplacer, parseComments, parseFunctionDictComments, todo, dictAssertion, boundModularIncrement, construct, reduceToString2, pageTurner, assignCumulative, defaultMergeStrategy, dictSetter3, toArguments, reTemplate, parseFrontmatter, typeAssertion, defineGetter, assignAllowed, simpleRecursiveWalk, simpleArgument, exprTemplater, stringifyIfNotPrimitive, panic, stringerf, wrapFunction, regexTemplater, iso8601, strftime, walkChildEntries, getFiletype, matchf, isUrl, looksLikeFunction, toArgument2, notNull, CumulativeStorage2, simpleAssign, findAndMatch, infuseObjectArray, regexGetter, splitArg, isJavascriptComment, runTest, everyOther, splitByRange, get_regex, getImports, isJavascriptFile, isValidDateString, WriteObject, equalityf, group2, splitOnce2, dedent4, isLowerCase, looksLikeRegExpString, isRegExpString, getDependencies, camelSplit, toggle3, countf, isLiteralObject, bindMethodsAndState2, call, mget3, looks_like_object_function, create_functions_from_master, toStringArgumentPretty, codeChunks, smart_map, run_tests, hasStartingCallable, mapTemplate, aliaser, fixSelector, htmlTags, removePythonComments, simpleStringBreaker, colonConfig, operations, error, redColon, so2, group, parseSingleLineJson, Items, findDependencies, tryf, find4, localeString, cssComment, colonConfigf, trimArray, parseCallable, bringToLifeTextFix, localBringToLife, getCaller4, getErrorStack, forEach, getBindings, getExports, matchstr, filter4, allEqual, count, isNativeFunction, repeat, eat, getIndentAndText, StopWatch, stringDictSetter, getFunctionInfo, runRef, toLines, hasCallable, getProseWords, tally, paramify, codeSplit, debugConfig, logConfig, blueColon, toStringArgument3, stringCallable, simpleBinding, dashSplit4, appendBelow, appendAbove, removeLineComments, prependIfNecessary, smartDedent4, blueSandwich, walk4, findLineIndex, parseAB, applyTransform, kebabCase, getExcerpt, sortObject, buildFunction, maybeSort, parseFunction, isTypable, frontMatter, dictEntry, insertAfterIndex, State, bindMethods, cpop, tagRE, toggle2, createFunction2, assignIncrementedIndex, ufa, assignArray, regexFromComment, createParsersFromObject, imatch, globalConsoleDebug, bindMethodsAndState, isQuestion, oxfordComma, isUpperCase, getFunctionIdentifier, filter3, match, getMatch, alternatef, reCombine, assertion2, deepEqual, hasDollar, so, deepAssign, Tally, getFunctionNames, throwError, notEqual, tryString, prettyPrintCodeSnippet, prettyPrintErrorStack, iter, quotify, transformerf, assign, defineBinding, jspy, linebreak, stringCall2, reduce3, getClassParameters, assignOnTop2, isIdentifier, ndy, dashSplit3, runFunctionFromRef, equalf, alphabet, stateGetterFromSchema, mreplace, require, topLineComment, isChinese, replacef, ignoref, codeLibrary, splitLines, addArgumentQuotes, getBindings2, addCaret, mget2, getStartingConfig, incrementalEat, strlen, hr, setOnce, unescapeHtml, oxford, breakerf, runTests, map3, dateSplit, transformDict, walk3, toRegExp, tryAgainf, assertNotNull, getArgumentObject, isArgumentObject, typef, requireArg, keyAndValue, assignf, stateGetter3, objectFromArguments2, assignDefaults, transformValue, assign3, assignFresh3, evaluate3, scopedEvaluator, objectFromArguments, enforce, sub, filterObject, extractStartingJsonLikeConfig, unbrackify, newlineIndent2, deleteLine, both, normalizeIndent, getComment, secondComment, isStringRegExp, dashSplit2, clock, warning, errorStringify, alert, labelCase, bottomComment, stringCompose, getAnyIdentifier, chalkf, getNumbers, partitions, has, addUnit, toCallable, unquote, filter2, warn2, join2, caller2, assignOnce, longShort, shortLong, argPop, caller, assignOnTop, toggle, defineWindow, unescapeNewlines, escapeQuotes, unescapeQuotes, escapeNewlines, setAliases, announceCaller, removeStartingComments, smartBind, assignExisting, isObjectWithKey, eatStart, modularIncrementItem, getRegex, runFunction, isObjectLikeArray, itemGetter2, getAllKeys, prefixSlice, hasQuotes, assertion, diff, toggleState, initState, dunder, objectGetter, superTransform, popFilter, testRunner, assert2, insertAtDollar, popEmptyLine, getOptions, mergeSpecs, sortByKeys, map2, strictMessengerAssert, smartSplit, chalk4, typeLog, getFunctionName, Clock, search3, MyError, fuzzyMatch3, debugDisplay, getCaller3, messengerAssert, camelSlice, setPrototype, assignAliases, display, modifyNumber, toDict, setPush, modularIncrementIndex, longstamp, popIndex, toggleOnOff, locWrap, walk2, typeMatch, prettyStringify, getIdentifiers, CustomError, argMatch, brackify2, smartestDedent, modularIncrementNumber, AbstractMethodError, allUnique, Trie, boundarySplit, numberBoundarySplit, nodeLog, getFirst, defineProperty, supermix, partial, timeLog, timestamp, raise, getIdentifier, conditionalPrefix, conditionalSuffix, QueryList, fuzzyMatch2, buildDict, getTextAndCommand, sprawlFactory, getParameters2, pushf, intersection, union, blue, green, sandwich, getLastSpaces, smartDedent3, red, sort, debounce, checkValue, getCodeChunks, logf, boundary, myError, conditional, isStringFunction, toSpaces, objectf, searchAll, difference, singleQuote, itemGetter, slice2, mergeObjects, once, dashSplit, nchalk, coerceToObject, ArrayState, exporter2, indent2, iterator, removeAllComments, countParams, cumulativeSchemaAssign, argKwargSplit, argParse, removeInlineComments, getFrontMatter, hasHtmlSuffix, lazyArray, isThisFunction, escapeHTML, getKwargs2, search2, toStringArgument, createFuzzyMatch, edit2, splice, zip, merge2, argArgsKwargs, fill2, chalk, vueWrap, splitArray, splitArray2, warn, makeRunner2, searchf2, smartDedent2, dedent2, toArray2, stateGetter2, sortByIndex, IndexedCache, argo, curry2, doUntil2, evaluate2, findall2, findIndex2, findItem2, getCaller2, getErrorStack2, isJson, indexGetter2, insert2, pop2, parseError2, remove2, reduce2, testf2, type2, unshift2, waterfall2, xsplit2, Cache, cumulativeAssign, replaceBefore, topComment, isAsyncFunction, mapSort, getFileURI, getQuotes, isClassObject, isInitialized, getFallback, bindingRE, addObjectOrObjectProperty, forDoubles, isCss, log, iterate, backAndForth, round, iteratorWrapper, toJSON, isFromMap, toString, empty, conditionalString, getConfigArg, hasKey, errorWrap, successWrap, check, toPoints, bind, mixinAliases, isPercentage, isBasicType, reducerStrategy, gather, entries, stateGetter, methodCase, vueCase, push2, smarterIndent, lineSplit, Store, isSingleLetter, prepareText, isSymbol, getShortest, slice, KeyError, deepCopy, argsKwargs, isError, isColor, list, objectEditor, matchall, makeFastRunner, announce, hasLetter, filter, reduce, stringCall, capitalizeName, stop, proseCase, lineDitto, mixinSetters, modularIncrement, distinct, definedSort, groupBy, reWrap2, fuzzyMatch, isPlural, Element, parseError, isPrimitiveArray, callableArgsKwargs, waterfall, defineVariable, info, flat2D, splitThePage, handleError, dedent, TypeAssertion, createFunction, pluralize, remove, Group, PageStorage, Storage, UniqueStorage, Watcher, arrayToDict, addProperty, addQuotes, argWrapFactory, assert, abrev, abf, addExtension, assignFresh, antif, atFirst, atSecond, backspace, bindObject, breaker, blockQuote, brackify, bringToLife, comment, countCaptureGroups, capitalizeTitle, classMixin, callableRE, camelToTitle, curry, createVariable, changeExtension, curryStart, curryEnd, capitalize, copy, camelCase, compose, char2n, camelToDash, deepMerge, datestamp, doublef, dictSetter, dictSetter2, dsearch, doUntil, dashCase, doubleQuote, dict, dictGetter, depluralize, dreplace, dictf, endsWithWord, exporter, edit, exists, evaluate, extend, find, flatMap, fill, fixUrl, functionGetter, findall, fixPath, flat, fparse, findIndex, firstLine, ftest, getKwargs, getFirstName, getBindingName, getParameters, getLastWord, getCodeWords, getCodeWords2, getIndent, getExtension, getLast, getLongest, getChunks, getCaller, getStackTrace, getConstructorName, getFirstWord, getWords, getSpaces, hasComma, hasSpaces, hasHtml, hasBracket, hasNewline, hasCaptureGroup, hasEquals, hasValue, hasCamelCase, hasNumber, hackReplace, insert, indexGetter, incrementf, isCallable, isQuote, isEven, isOdd, isLast, isHTML, isNode, interweave, inferLang, isString, isArray, isObject, isDefined, isFunction, isPrimitive, isNumber, isSet, isNestedArray, indent, isNull, isWord, isBoolean, isRegExp, identity, isObjectLiteral, isJsonParsable, isCapitalized, isNewLine, isObjectArray, isStringArray, isClassFunction, joinSpaces, join, keyArrayToObject, lowerCase, linebreakRE, len, lineGetter, lineCount, lastLine, logConsole, makeRunner, mixin, modularf, matchGetter, merge, mget, map, mergeOnTop, mergeToObject, mapFilter, noop, nestPush, no, newlineIndent, n2char, objectWalk, overlap, objectToString, opposite, pipe, parseTopAttrs, pascalCase, partition, parens, push, pop, parseJSON, rigidSort, removeQuotes, rep, removeComments, range, removeExtension, rescape, reverse, reWrap, reduceToString, repeatUntil, swapKey, sayhi, swap, splitMapJoin, splitCamel, smallify, search, stringify, shared, smartDedent, stringBreaker, sleep, split, snakeCase, stringArgument, sorted, splitOnce, searchf, secondLine, titleCase, textOrJson, toNumber, toArgument, toNestedArray, test, type, tail, transformObject, trim, testf, toArray, templater, totalOverlap, upperCase, unique, uncapitalize, unzip, wrap, walk, wrapf, xsplit, yes, zip2} from "/home/kdog3682/2023/utils.js"
function applyExponentGroupingEffect() {

}

const fnRef = {
    exp: expand,
}
const expansionRef = {
    NUMBER(node) {
        
    }
}
function expand(node) {
    return 
    return expansionRef[node.type](node)
}
const TokenSpecs = [
    { type: "LABEL", regex: /^(red|blue|green):/, kind: "identifier", spacing: 'label' },
    { type: "SPACE", regex: /^\s+/, kind: "whitespace" },
    { type: "NUMBER", regex: /^(?:\d+(?:\.\d*)?|\.\d+)/, kind: "literal" },
    { type: "ADDITION", regex: /^\+/, display: '+', kind: "operator", precedence: 1 },
    { type: "ADDITION", regex: /^p/, display: '+', kind: "operator", precedence: 1 },
    { type: "DIVISION", regex: /^d(?:iv)?/, display: '÷', kind: "operator", precedence: 2 },
    { type: "EXPONENTIATION", regex: /^e(?!xp)/, display: '^', kind: "operator", precedence: 4 },
    { type: "EXPONENTIATION", regex: /^g/, display: '^', kind: "operator", precedence: 4, spacing: 'gexp' },
    { type: "MULTIPLICATION", regex: /^t/, display: '*', kind: "operator", precedence: 2 },
    { type: "CHAR", regex: /^[abcmnxyz](?=[^abcmnxyz]|$)/, kind: "identifier" },
    { type: "SUBTRACTION", regex: /^[_-]/, kind: "operator", precedence: 1 , display:"-"},
    { type: "MULTIPLICATION", regex: /^\*/, display: '*', kind: "operator", precedence: 2 },
    { type: "FRACTION", regex: /^\/{2}/, kind: "operator", precedence: 2, spacing: 'gfrac', display: '/' },
    { type: "FRACTION", regex: /^\//, kind: "operator", precedence: 2 },
    { type: "EXPONENTIATION", regex: /^\^/, display: '^', kind: "operator", precedence: 4 },
    { type: "PARENTHESIS_LEFT", regex: /^\(/, kind: "delimiter" },
    { type: "PARENTHESIS_RIGHT", regex: /^\)/, kind: "delimiter" },
    { type: "SEMICOLON", regex: /^;/, kind: "delimiter" },
    { type: "COMMA", regex: /^,/, kind: "delimiter", apply: 'throw' },
    { type: "ASSIGNMENT", regex: /^\=/, kind: "operator", precedence: 10, spacing: 'assignment' },
    // { type: "EQUALS", regex: /^\=/, kind: "operator", precedence: 0 },
    { type: "WORD", regex: /^[a-z]+/, kind: "identifier" },
]

const TokenTypes = reduce(TokenSpecs, (x) => [x.type, x.type])
TokenTypes.EOF = 'EOF'
TokenTypes.SOF = 'SOF'

class Tokenizer {
    constructor(input) {
        this.terminal_right_parentheses = 0
        this.lp = 0
        this.input = input
        this.cursor = 0
        this.getAllTokens()
        // console.log(this.tokens)
        /* @bookmark 1708721750 this.tokens */
        this.tokens = this.tokens.filter((x) => x.type != TokenTypes.SPACE)
    }

    hasMoreTokens() {
        return this.cursor < this.input.length
    }

    match(regex, inputSlice) {
        const matched = regex.exec(inputSlice)
        if (matched === null) {
            return null
        }

        this.cursor += matched[0].length
        return getMatch(matched)
    }

    getNextToken() {
        return this.tokens.shift()
    }
    parseNextToken() {
        if (!this.hasMoreTokens()) {
            return null
        }

        const inputSlice = this.input.slice(this.cursor)

        for (const spec of TokenSpecs) {
            let match = this.match(spec.regex, inputSlice)

            // No rule was matched!
            if (match === null) {
                continue
            }

            // Skip whitespace!
            if (spec.type === TokenTypes.SPACE) {
                // this.fill()
                // return true
                return {
                    type: TokenTypes.SPACE
                }
            }

            if (spec.type === null) {
                return this.parseNextToken()
            }

            if (spec.display) {
                match = spec.display
            }
            if (spec.apply) {
                if (spec.apply == 'throw') {
                    panic('this token is not currently allowed: $1', match)
                }
            }
            if (spec.spacing) {
                if (spec.spacing == 'label') {
                    this.tokens.push({
                        type: spec.type,
                        value: match,
                        kind: spec.kind,
                    })
                    this.pushParentheses()
                    return true
                }

                if (spec.spacing == 'gexp') {
                    this.pusher(match, spec)
                    this.pushParentheses()
                    return true
                }
                if (spec.spacing == 'assignment') {
                    this.tokens.unshift(generated('('))
                    this.tokens.push(generated(')'))
                    this.pusher(match, spec)
                    this.pushParentheses()
                    this.terminal_right_parentheses += 1
                    return true
                }

                if (spec.spacing == 'gfrac') {
                    this.pushFarLeftParentheses()
                    this.pushParentheses('right')
                    this.pusher(match, spec)
                    this.pushParentheses()
                    return true
                }
            }

            return this.pusher(match, spec)
        }

        throw new SyntaxError(`Unexpected token: "${inputSlice[0]}"`)
    }
    pusher(match, spec) {
        const payload = {
                type: spec.type,
                value: match,
                kind: spec.kind,
        }
        if (spec.precedence != null) {
            
                payload.precedence =  spec.precedence
        }
        this.tokens.push(payload)
        return true
    }

    pushParentheses(right) {
        if (right) {
            this.tokens.push({
                type: TokenTypes.PARENTHESIS_RIGHT,
                generated: true
            })
            return 
        }
        this.lp += 1
        this.tokens.push({
            type: TokenTypes.PARENTHESIS_LEFT,
            generated: true
        })
    }

    pushFrac() {
        this.tokens.push({
            type: TokenTypes.FRACTION,
            generated: true,
            kind: 'operator',
            precedence: 3,
        })
    }

    pushFarLeftParentheses() {
        const index = findIndex2(this.tokens, (x) => {
            return x.type == TokenTypes.SPACE
        }, -1) || 0
        insert2(this.tokens, 1 + index, {
                        type: TokenTypes.PARENTHESIS_LEFT,
                        generated: true
        })
    }
    pushOperator(key) {
        this.tokens.push({
            type: TokenTypes[key],
            generated: true,
            kind: 'operator',
            value: '%',
        })
    }

    getAllTokens() {
        // this.tokens = [{type: TokenTypes.SOF}]
        this.tokens = []
        while (true) {
            const token = this.parseNextToken()
            if (token) {
                if (token == true) {
                    continue
                } else {
                    this.tokens.push(token)
                }
            } else {
                this.fill()
                for (let i = 0; i < this.terminal_right_parentheses; i++) {
                    this.tokens.push(generated(')'))
                }
                return 
            }
        }
    }
    fill() {
                for (let i = 0; i < (this.lp || 0); i++) {
                    this.tokens.push({
                        type: TokenTypes.PARENTHESIS_RIGHT,
                        generated: true
                    })
                }
            this.lp = 0
    }

    printAllTokens() {
        let token
        while ((token = this.getNextToken())) {
            console.log(token)
        }
    }
}

class Parser {
    parse(input) {
        this.input = input
        this.tokenizer = new Tokenizer(input)
        // this.
        this.lookahead = this.tokenizer.getNextToken()
        return this.Expression()
    }
    maybeEat(tokenType) {
        if (this.lookahead.type == tokenType) {
            return this._eat()
        }
    }
    _eat() {
        const token = this.lookahead
        this.lookahead = this.tokenizer.getNextToken()
        return token
    }

    eat(tokenType) {
        const token = this.lookahead
        if (arguments.length == 0) {
            return this._eat()
        }

        if (token == null) {
            throw new SyntaxError(
                `Unexpected end of input, expected "${tokenType}"`
            )
        }

        if (token.type !== tokenType) {
            throw new SyntaxError(
                `Unexpected token: "${token.value}", expected "${tokenType}"`
            )
        }
        return this._eat()
    }

    getPrecedence(token, implicit) {
        if (token === "unary") {
            return 4
        }
        if (!token) {
            return 0
        }
        if (token.type === TokenTypes.PARENTHESIS_RIGHT) {
            return 0
        }

        if (token.type === TokenTypes.SPACE) {
            throw 'space should never be seen'
        }

        const prec = token.precedence
        if (implicit) {
            return 100
        }
        // console.log(prec, token)
        return prec
    }

    UnaryExpression() {
        this.eat(TokenTypes.SUBTRACTION)

        return {
            type: "UnaryExpression",
            value: this.Expression(this.getPrecedence("unary"))
        }
    }
    BaseCharAtom() {
        const base = this.eat(TokenTypes.CHAR)
        if (this.nt == TokenTypes.NUMBER) {
            return {
                left: base, right: this.eat(), type: 'BinaryExpression',
                operator: '^', generated: true
            }
        }
        return base
    }
    get nt() {
        return this.lookahead?.type
    }
    BaseNumberAtom() { 
        const base = this.eat(TokenTypes.NUMBER)
        const next = this.nt
        if (next == TokenTypes.CHAR) {
            return {
                type: 'atom',
                args: [base, this.BaseCharAtom()]
            }
        } else {
            return base
        }
    }

    FunctionExpression() {
        const left = this.eat()
        this.eat(TokenTypes.PARENTHESIS_LEFT)
        const right = this.Expression()
        this.eat(TokenTypes.PARENTHESIS_RIGHT)
        return {
            type: 'FunctionExpression',
            left,
            right,
        }
    }
    LabeledExpression() {
        const left = this.eat()
        this.eat(TokenTypes.PARENTHESIS_LEFT)
        const right = this.Expression()
        this.eat(TokenTypes.PARENTHESIS_RIGHT)
        return {
            type: 'LabeledExpression',
            left,
            right,
        }
    }
    Prefix(implicit) {

        const next = this.lookahead.type
        if (next === TokenTypes.LABEL) {
            return this.LabeledExpression()
        }

        if (next === TokenTypes.PARENTHESIS_LEFT) {
            return this.ParenthesizedExpression()
        }
        if (next === TokenTypes.SUBTRACTION) {
            return this.UnaryExpression()
        }
        if (next == TokenTypes.NUMBER) {
            return this.BaseNumberAtom()
        }

        if (next == TokenTypes.CHAR) {
            return this.BaseCharAtom()
        }

        if (next == TokenTypes.WORD) {
            return this.FunctionExpression()
        }
        // console.log(this)
        // console.log()
        const knownWords = [
            "yet",
        ]

        if (isWord(this.input)) {
            if (knownWords.includes(this.input)) {
                throw 'isword'
            }
            panic('possibly interjected prose into math: $1', this.input)
        }
        panic('no prefix found for token: $1', next)
    }

    look() {
        console.log('looking', {s: this.input, cursor: this.tokenizer.cursor, remaining: this.input.slice(this.tokenizer.cursor)})
    }
     // * Infix
     // *    = (" " | "+" / "-" / "*" / "/" / "^") Expression
     // */
    Infix(left, operatorType, implicit) {
        let operatorToken = this.eat(operatorType)
        // console.log({operatorToken, implicit})
        // eating the exponent operator
        const prec = operatorToken.precedence
        // console.log(operatorToken)
        // console.log({prec})
        // console.log(prec); throw "prec"
        // console.log({operatorToken})
        if (operatorToken.type == TokenTypes.EXPONENTIATION) {
            if (this.implicitNotAllowed) {
                
            } else {
                this.implicit = true
            }
            // console.log('starting implicit')
        }

        return {
            type: "BinaryExpression",
            operator: operatorToken.value,
            left,
            right: this.Expression(prec, implicit)
        }
    }
    Expression(prec = 0, implicit = false) {
        let left = this.Prefix()
        // console.log({left})
        while (prec < this.getPrecedence(this.lookahead)) {
            left = this.Infix(left, this.lookahead?.type)
        }
        return left
    }

    ParenthesizedExpression() {
        let paren = this.eat(TokenTypes.PARENTHESIS_LEFT)
        const expression = this.Expression()
        if (!paren.generated) {
            expression.parens = true
        }
        this.eat(TokenTypes.PARENTHESIS_RIGHT)
        return expression
    }
}

class NodeVisitor {
    constructor() {
        this.count = 0
    }
    visitLabeledExpression(node) {
        const value = node.left.value

        const right = this.visit(node.right)
        return colored(right, value)
    }
    visitAssignment(node) {
        return node.left + ' = ' + node.right
    }
    resolvedVisit(node) {
        const value = this.visit(node)
        if (isObject(value)) {
            return value.value
        }
        return value
    }
    visitFunctionExpression(node) {
        const key = node.left.value
        if (key == 'exp') {
            // console.log(node.right)
            return `#exp($${this.resolvedVisit(node.right)}$)`
        }
        return fnRef[key](node.right)
    }
    visit(node) {
        const value = this._visit(node)
        if (node.parens) {
            return parens(value)
        }
        return value
    }
    visitAtom(node) {
        return node.args.map((x) => this.resolvedVisit(x)).join('')
        // throw node
    }
    _visit(node) {
        this.count += 1
        try {
                    // console.log(node.type)
            switch (node.type) {
                case 'FunctionExpression':
                    return this.visitFunctionExpression(node)
                case "ASSIGNMENT":
                    return this.visitAssignment(node)
                case "Number":
                    return this.visitNumber(node)
                case 'atom':
                    return this.visitAtom(node)
                case "NUMBER":
                case "CHAR":
                    return this.visitNumber(node)
                case "BinaryExpression":
                    return this.visitBinaryExpression(node)
                case "UnaryExpression":
                    return this.visitUnaryExpression(node)
                case "LabeledExpression":
                    return this.visitLabeledExpression(node)
            }
        } catch(e) {
            throw e
             // console.log(node)
            // throw e.toString()
        }
    }

    visitNumber(node) {
        if (this.count == 1) {
            return colored(node.value, node.color)
        }
        return node
    }

    visitBinaryExpression(node) {
        // console.log(node)
        if (node.operator == '^') {
            if (node.left.operator == '^') {
                node.left.parens = true
            }
        }
        const left = this.visit(node.left)
        const right = this.visit(node.right)
        if (left == null || right== null) {
            console.log(node)
            throw 'aa'
        }
        // console.log(left, right)
        return wrapper(left, node.operator, right)
    }

    visitUnaryExpression(node) {
        return '-' + this.visit(node)
    }
}

const colorRef = {
  "r": "red",
  "o": "orange",
  "y": "yellow",
  "g": "green",
  "b": "blue",
  "i": "indigo",
  "v": "violet",
  "p": "pink",
  "w": "white",
  "k": "black",
}
function colored(a, color) {
    if (color == null) {
        return a
    }
    if (isObject(a)) {
        a = a.value
    }
    color = colorRef[color] || color
    return `#x${color}($${a}$)`
    return `#text(fill: ${colorRef[color]}, $${a}$)`
}
function wrapper(a, op, b) {
    if (isString(a)) {
        a = {value: a}
    }
    if (isString(b)) {
        b = {value: b}
    }
    op = operatorRef[op]
    let right = b.value
    let left = a.value
    let delim = op.pad ? wrap(op.display, ' ') : op.display
    if (op.name == 'exp') {
        if (right.color) {
            right = colored(right, b.color)
            left = colored(left, a.color)
        } else {
            right = colored(right, a.color)
        }
        // throw [a, b]
    } else {
        right = colored(right, b.color)
        left = colored(left, a.color)
    }
    if (op.wrapBoth) {
        right = wrap(right, '()')
        left = wrap(left, '()')
    }

    if (op.wrapRight && right.length > 1) {
        right = wrap(right, '()')
    }
    // console.log({left, delim, right})

    let value = left + delim + right
    if (op.wrapOuter) {
        value = wrap(value, '()')
    }
    if (op.displayMode) {
        return `display(${value})`
    }
    return value
}

const operatorRef = {
  "+": {"symbol": "+", "name": "plus", "display": "+", "pad": true, "wrap": false},
  "*": {"symbol": "*", "name": "times", "display": "*", "pad": true, "wrap": false},
  "=": {"symbol": "=", "name": "equal", "display": "=", "pad": true, "wrap": false},
  "-": {"symbol": "-", "name": "minus", "display": "-", "pad": true, "wrap": false},
  "^": {"symbol": "^", "name": "exp", "display": "^", "pad": false, "wrap": 'second', wrapRight: true},
  "/": {"symbol": "/", "name": "frac", "display": "/", "pad": true, "wrapBoth": true, 'wrapOuter': false, displayMode: true, 'recursive': true},
  "÷": {"symbol": "div", "name": "divide", "display": "÷", "pad": true, "wrap": 'both', 'wrapOuter': true}
}


const s = lastLine(`
2e3
2xe33
a(aasd"as)
2xg3123p1


    2g3p5p6/7
    2e(3e5)
1p red:3p2p5//blue:3
    2e3=1223
    123 = 2e7x

// exp(25) / exp(123)
(1 + 2 + 3)
2p3e2=123
2e3e5e7
2e3e4t2e5=2e2x-1
// 3t4p5=2x_1
yet
aem
ag2x
ag2xpag3
fooga
goa
`)



const v = new NodeVisitor()
const c = new Parser()
function parser(s) {
    try {
        return wrap(v.visit(c.parse(s)), '$')
    } catch(e) {
        // console.log(e)
        if (e == 'isword') {
            return s
        }
        throw e
    }
}
export default parser
// console.log(parser(s))

// const mathRE7 = /(?:(?:\(?(?:[a-z]\w*:)?(?:(?:\d+\.)?\d\w*(?:e(?:\d+\.)?\d\w*|%)?|\d*[xyzmnabc](?:\d|e\w+))\)?)(?:(?: *(?:[pt+*=-]|\/{1,2}) *)(?:\(?(?:[a-z]\w*:)?(?:(?:\d+\.)?\d\w*(?:e(?:\d+\.)?\d\w*|%)?|\d*[xyzmnabc](?:\d|e\w+))\)?))+|(?:[a-z]\w*:)?(?:\d+\.)?\d\w*e(?:\d+\.)?\d\w*|(?:[a-z]\w*:)?\d*[xyzmnabc](?:\d|e\w+))/g
// console.log(tok.tokens)
// console.log(tok.getAllTokens())
// const ast = c.parse(s)
// const val = v.visit(ast)
// console.log(val)
function generated(key) {
    const ref = {
        '(': TokenTypes.PARENTHESIS_LEFT,
            ')': TokenTypes.PARENTHESIS_RIGHT,
    }
    if (key in ref) {
        return {
            type: ref[key],
            generated: true,
        }
    }
}
/* @bookmark 1708721750 this.tokens */
